<!DOCTYPE html>
<html lang="ch">
  <head>
    <meta charset="utf-8" />
<title>HTTP/2 抓包遇到的坑</title>
<meta name="description" 
      content=""
>

  




<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link
  rel="alternate"
  type="application/rss+xml"
  href="https://schecterdamien.github.io/index.xml"
  title=""
/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="HTTP/2 抓包遇到的坑"/>
<meta name="twitter:description" content="上一篇文章介绍了http2协议相关的细节。因为是为了准备分享，所以为了尽可能直观的展示协议通信（特别是握手协商）的整个过程，还是决定准备一下小的demo然后抓包演示下。在这个过程也遇到了一些问题，耽搁了不少时间，所以记录一下整个过程
h2c抓包 分别对HTTP2的两种建立链接的方式进行抓包（h2c和h2），先演示h2c的连接建立过程，准备的server端的代码如下：
package main import ( &#34;fmt&#34; &#34;log&#34; &#34;net/http&#34; &#34;golang.org/x/net/http2&#34; &#34;golang.org/x/net/http2/h2c&#34; ) // http2 h2c func main() { h2s := &amp;http2.Server{} handler := http.NewServeMux() handler.HandleFunc(&#34;/ping&#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, &#34;pong&#34;) }) s := &amp;http.Server{ Addr: &#34;:5005&#34;, Handler: h2c.NewHandler(handler, h2s), } http2.ConfigureServer(s, &amp;http2.Server{}) log.Fatal(s.ListenAndServe()) } 然后打开wireshark，监听本地的5005端口，使用curl请求server，这里需要指定&ndash;http2使用http2协议，不然的话curl默认使用http1.1：
curl --http2 http://localhost:5005/ping 可以在wireshark里看到建立连接的过程：
上图是客户端(curl)发送的http1.1的协议升级请求。这里能看到上篇文章提到的协议升级的关键的header。Connection指定header有哪些逐跳头部，Upgrade指定客户端希望升级到http2协议，HTTP2-Settings则指定了连接的初始参数。
上图是服务端的http response。返回了Upgrade表示服务端同意升级到http2协议，然后客户端和服务端就可以使用http2通信了。
h2c抓包遇到的问题 虽然在上文已经提到了结论：
go在1.6开始支持HTTP/2，这个时候只支持HTTP/2 over TLS，也就是h2。只要是TLS部署，则http库就会默认进行HTTPS/2协商，协商失败则蜕化为HTTPS/1 go在1.8开始支持 HTTP/2 server push go在1.11开始支持 HTTP/2 h2c gin目前只支持h2方式的HTTP/2，不支持h2c方式的HTTP/2 但是在一开始对于go里是怎么支持http2是不太清楚的，是在第三方库里支持还是net/http直接支持？是h2c和h2两种方式都支持还是只支持h2？google的时候很多文章又语焉不详，所以在准备一段h2c server代码的时候比较曲折。"/>



<link rel="stylesheet" href="https://schecterdamien.github.io/fontawesome/css/all.min.css" />




<link
  crossorigin="anonymous"
  href="/css/styles.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>




<link
  id="dark-mode-theme"
  crossorigin="anonymous"
  href="/css/dark.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>


<script>
  var darkTheme = document.getElementById('dark-mode-theme')
  var storedTheme = localStorage.getItem('dark-mode-storage')

  if (storedTheme === 'dark') {
    darkTheme.disabled = false
  } else if (storedTheme === 'light') {
    darkTheme.disabled = true
  }
</script>


<script defer crossorigin="anonymous" src="/js/theme.js" integrity=""></script>


<script defer crossorigin="anonymous" src="/js/instantpage.min.js" integrity=""></script><meta name="generator" content="Hugo 0.101.0" />
  </head>
  <body>
    
  




  <header>
    <nav class="navbar">
  <div class="nav">
    
      <a href="https://schecterdamien.github.io/" class="nav-logo">
        <img
          src="https://schecterdamien.github.io/images/icon.png"
          width="50"
          height="50"
          alt="Logo"
        />
      </a>
    

    <ul class="nav-links">
      
        
          <li>
            <a href="/about/" id="About"
              ><em class="fas fa-user fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/tags" id="Tags"
              ><em class="fas fa-tag fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/search" id="Search"
              ><em class="fas fa-search fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/archives" id="Archives"
              ><em class="fas fa-archive fa-lg"></em
            ></a>
          </li>
          
      
    </ul>
  </div>
</nav>

    <div class="intro-header">
      <div class="container">
        <div class="posts-heading">
          
            <h1>
              HTTP/2 抓包遇到的坑
            </h1>
          
          
        </div>
      </div>
    </div>
  </header>
  

    
  <div class="container" role="main">
    <article class="article" class="blog-post">
      
  <p>     <a href="/posts/2019/http2/">上一篇文章</a>介绍了http2协议相关的细节。因为是为了准备分享，所以为了尽可能直观的展示协议通信（特别是握手协商）的整个过程，还是决定准备一下小的demo然后抓包演示下。在这个过程也遇到了一些问题，耽搁了不少时间，所以记录一下整个过程</p>
<h3 id="h2c抓包">h2c抓包</h3>
<p>     分别对HTTP2的两种建立链接的方式进行抓包（h2c和h2），先演示h2c的连接建立过程，准备的server端的代码如下：</p>
<pre tabindex="0"><code>package main

import (
	&#34;fmt&#34;
	&#34;log&#34;
	&#34;net/http&#34;

	&#34;golang.org/x/net/http2&#34;
	&#34;golang.org/x/net/http2/h2c&#34;
)

// http2 h2c
func main() {
	h2s := &amp;http2.Server{}

	handler := http.NewServeMux()
	handler.HandleFunc(&#34;/ping&#34;, func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, &#34;pong&#34;)
	})

	s := &amp;http.Server{
		Addr:    &#34;:5005&#34;,
		Handler: h2c.NewHandler(handler, h2s),
	}

	http2.ConfigureServer(s, &amp;http2.Server{})
	log.Fatal(s.ListenAndServe())
}
</code></pre><p>     然后打开wireshark，监听本地的5005端口，使用curl请求server，这里需要指定&ndash;http2使用http2协议，不然的话curl默认使用http1.1：</p>
<pre tabindex="0"><code>curl --http2 http://localhost:5005/ping
</code></pre><p>     可以在wireshark里看到建立连接的过程：</p>
<p><img src="/img/http2-wireshark/w1.jpg" alt=""></p>
<p>     上图是客户端(curl)发送的http1.1的协议升级请求。这里能看到上篇文章提到的协议升级的关键的header。<code>Connection</code>指定header有哪些逐跳头部，<code>Upgrade</code>指定客户端希望升级到http2协议，<code>HTTP2-Settings</code>则指定了连接的初始参数。</p>
<p><img src="/img/http2-wireshark/w2.jpg" alt=""></p>
<p>     上图是服务端的http response。返回了<code>Upgrade</code>表示服务端同意升级到http2协议，然后客户端和服务端就可以使用http2通信了。</p>
<h5 id="h2c抓包遇到的问题">h2c抓包遇到的问题</h5>
<p>     虽然在上文已经提到了结论：</p>
<ul>
<li>go在1.6开始支持HTTP/2，这个时候只支持HTTP/2 over TLS，也就是h2。只要是TLS部署，则http库就会默认进行HTTPS/2协商，协商失败则蜕化为HTTPS/1</li>
<li>go在1.8开始支持 HTTP/2 server push</li>
<li>go在1.11开始支持 HTTP/2 h2c</li>
<li>gin目前只支持h2方式的HTTP/2，不支持h2c方式的HTTP/2</li>
</ul>
<p>     但是在一开始对于go里是怎么支持http2是不太清楚的，是在第三方库里支持还是net/http直接支持？是h2c和h2两种方式都支持还是只支持h2？google的时候很多文章又语焉不详，所以在准备一段h2c server代码的时候比较曲折。<br>
     先是直接写了一个简单的gin的demo，然后用curl &ndash;http2抓包，发现server端总是不识别升级请求，后续还是使用http1.1通信，然后找gin的文档，只是写到gin支持http2 push（那说明gin肯定还是支持http2呗，但是h2c就是无法成功），后来在gin的源码里搜索h2c，无果，看issue，找到结果了，有人提了<a href="https://github.com/gin-gonic/gin/pull/1398">相关pr</a>，然后又看了几篇其他文章才明白go本身官方库net里就支持http2了，h2和h2c两种方式都支持，是在gin这一层不支持h2c。然后看到了<a href="https://colobu.com/2018/09/06/Go-http2-%E5%92%8C-h2c/">这篇文章</a>，改了下终于能跑一个支持h2c的server了</p>
<h3 id="h2抓包">h2抓包</h3>
<p>     h2是通过tls协商建立http2连接，这种方式更具有实际意义，因为h2是更提倡的也是更安全普遍的建立http2的方式，先附上server端代码：</p>
<pre tabindex="0"><code>package main

import (
	&#34;fmt&#34;
	&#34;log&#34;
	&#34;net/http&#34;

	&#34;golang.org/x/net/http2&#34;
)

// http2 h2
func main() {
	http.HandleFunc(&#34;/ping&#34;, func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, &#34;pong&#34;)
	})

	srv := &amp;http.Server{
		Addr: &#34;:5005&#34;,
	}
    
   // 下面这一行代码可以省略，因为net/http会自动进行协议协商，优先选择建立http2链接
	http2.ConfigureServer(srv, &amp;http2.Server{})
	log.Fatal(srv.ListenAndServeTLS(&#34;/Users/wujinjing/projects/360/go/stack.crt&#34;, &#34;/Users/wujinjing/projects/360/go/stack.key&#34;))
}
</code></pre><p>     然后打开wireshark，监听本地的5005端口，使用curl请求server：</p>
<pre tabindex="0"><code>curl --http2 http://localhost:5005/ping -k
</code></pre><p>     发现抓到的包是这样的：</p>
<p><img src="/img/http2-wireshark/w3.jpg" alt=""></p>
<p>     看不到http2连接的报文，协议也显示的是TLSv1.2，而不是http2。刚开始我一直以为是不是哪里有问题，server代码有问题或者client有问题，后来才突然想到，应用数据是被加密了，客户端和服务端两端在TLS上协商密钥加密通信，wireshark肯定就不知道TLS上应用层数据都是些什么，要想看到过程，必须要能解密流量。那么问题来了，wireshark怎么解密TLS协议之上的流量呢？</p>
<p>     然后又看了几篇文章（可以看看参考连接），根据TLS密钥协商的过程，wireshark想要解密TLS流量大概有两种办法，一种是拿到服务端的证书私钥，wireshark能直接用私钥解密出会话密钥，然后可以解密流量。一种是某些客户端支持把TLS握手过程中生成的密钥保存在外部文件中，可供wireshark解密使用。</p>
<h4 id="尝试第一种方式">尝试第一种方式</h4>
<p>     先尝试用直接导入证书私钥的方式来解密流量，重复检查配置了好几次，发现抓到的包还是没办法解密。然后google了下，发现这种方式只对RSA算法有用，因为如果是通过 RSA 算法交换秘钥，那么客户端会加密并发送给服务端，这样只需要知道服务端的私钥就可以解密出 PreMasterSecret 值。但是目前比较主流的方式都是使用DH类算法交换密钥，而DH类算法中的 PreMasterSecret 是由服务端和客户端各自计算出来，而且没有保存到磁盘，没有通过网络传输，这样就导致无法进行解密。</p>
<p>然后看了下Server Hello里服务端选择的Cipher Suite：<code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code>。刚好是ECDHE算法，这样的话，这种配置证书私钥的方式就失效了啊，怎么办呢，略加思索&hellip;.要不指定Cipher Suite？指定成RSA方式来交换密钥不就可以了吗，然后就开始在curl的时候指定tls的Cipher Suite，结果试了好几个，发现server都不支持，tls链接建立不起来，握手都过不了，一拍脑子才想起来，curl指定的是Client HELLO的Cipher Suite，是提供给server端选择的，这样直接指定一个很可能server不支持。那要不在curl默认的Client Hello里的Cipher Suite列表里找到一个RSA密钥交换类的，然后在server端来指定这个Cipher Suite？于是又开始漫长的找go里tls源码的旅途，最后是找到了，但是折腾一番，指定了好几个，发现还是会有问题，可能这些rsa的cipher suites都在go的http2实现中都不支持了？没有细细探究，感觉此路不通了，换种方式吧</p>
<h4 id="尝试第二种方式">尝试第二种方式</h4>
<p>     第二种方式是客户端把握手过程中生成的密钥保存在外部文件中供Wireshark解密使用，那最主要的便是客户端是否支持这种方式。亲测Chrom和Curl是支持的，首先在命令行<code>export SSLKEYLOGFILE=~/tls/sslkeylog.log</code>导入环境变量SSLKEYLOGFILE指定密钥文件的路径，然后再open Chrome，或者执行curl命令，都会自动把握手过程中的密钥都保存到这个文件中。接下来需要在wireshark里指定密钥文件：[Edit]-&gt;[Preference]-&gt;[Protocols]-&gt;[TSL] ，准备完毕就可以开始解密抓包了，至此终于能够查看http2的h2建立连接的过程了</p>
<p><img src="/img/http2-wireshark/w4.jpg" alt=""></p>
<p>tips：
     补充下，最近还遇到另外一个问题，需要排查某个服务到另外一个服务的https链接问题，需要抓包查看包内容，客户端是go的代码，其实也是可以配置SSLKEYLOGFILE的，这样wireshark就可以解密抓到的https流量了</p>
<pre tabindex="0"><code>f, err := os.OpenFile(&#34;keylog.txt&#34;, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0664)
if err != nil {
	log.Fatal(err)
}

client := http.Client{
	Transport: &amp;http.Transport{
		TLSClientConfig: &amp;tls.Config{
			KeyLogWriter:       f,
			InsecureSkipVerify: true,
		},
	},
}
</code></pre><h4 id="继续抓包">继续抓包</h4>
<p>     配置好了curl的<code>SSLKEYLOGFILE</code>环境变量和wireshark的相关配置，就可以观察到以下流量</p>
<p><img src="/img/http2-wireshark/w5.jpg" alt=""></p>
<p>     可以看到抓到的包里出现了http2协议的包了，说明wireshark已经解密出了TLS上层流量，能识别上层协议了。再来看下h2协议协商的过程。在上文提到过，h2的协议协商是借助TLS的一个扩展协议，ALPN（Application Layer Protocol Negotiation，应用层协议协商）来进行的。从上图可以看到，首先是在TLS的Client Hello里，客户端在扩展里添加了ALPN的内容，并且在里面指定了上层协议使用h2</p>
<p><img src="/img/http2-wireshark/w6.jpg" alt=""></p>
<p>     后面Server Hello里，服务端在扩展里添加了ALPN相关内容，确认了后续使用h2进行通信，到此为止借助tls本身的握手机制，h2的协议协商基本完成，后面就可以正常通信了</p>
<h3 id="参考链接">参考链接</h3>
<ul>
<li><a href="https://gohalo.me/post/decrypt-tls-ssl-with-wireshark.html">https://gohalo.me/post/decrypt-tls-ssl-with-wireshark.html</a></li>
<li><a href="https://blog.wonter.net/posts/f288be00/">https://blog.wonter.net/posts/f288be00/</a></li>
<li><a href="https://imququ.com/post/http2-traffic-in-wireshark.html">https://imququ.com/post/http2-traffic-in-wireshark.html</a></li>
</ul>




      
        <div class="blog-tags">
          
            <a
              href="https://schecterdamien.github.io/tags/web/"
              >web</a
            >&nbsp;
          
        </div>
      

      
        <ul class="bottomnav"><li class="next"><a href="/posts/2019/http2/"
          >HTTP/2 协议<span>&nbsp;>></span></a
        ></li></ul>

      
    </article>
    
    
      

    
  </div>

    <footer>
  

<div class="social-icons">
  
    
    
      
      <a href="link%20to%20social%20media" name="name of social media">
        <em class="A icon from https://fontawesome.com/"></em>
      </a>
    
  

  
</div>


  
  <div class="container">
    <p class="credits copyright">
      <a href="https://schecterdamien.github.io/about">wujinjing</a>
      &nbsp;&copy;
      2021
      
      &nbsp;&ndash;&nbsp;
      <em class="fas fa-moon" id="dark-mode-toggle"></em>
    </p>

    <p class="credits theme-by">
       <a href="https://gohugo.io">Hugo</a>&nbsp;
      
      <a href="https://github.com/matsuyoshi30/harbor">Harbor</a>
    </p>
  </div>
</footer>

  </body>
</html>
