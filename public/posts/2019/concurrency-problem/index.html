<!DOCTYPE html>
<html lang="ch">
  <head>
    <meta charset="utf-8" />
<title>记一次并发问题的排查</title>
<meta name="description" 
      content=""
>

  




<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link
  rel="alternate"
  type="application/rss+xml"
  href="https://schecterdamien.github.io/index.xml"
  title=""
/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="记一次并发问题的排查"/>
<meta name="twitter:description" content="起源 事情的起源是这样的，Binding是一张多对多的表，主要有sku_code，settlement_sn，enable这几个字段，但是逻辑上sku_code，settlemen_sn，enable=True的在表中应该是唯一的。因为enable=False可能有多条，所以不能在数据库上加联合唯一的索引，但是代码里面有判断。然后有一天测试发现出现两条记录的sku_code，settlemen_sn相同且enable都为True，然后看代码，创建Binding的代码大致是这样的
def create_binding(sku_code, settlement_sn)： if not Binding.objects.filter(sku_code=sku_code, settlement_sn=settlement_sn, enable=True).exist(): raise OperationError(&#39;binding_created&#39;) # 一系列有些耗时的校验 do_some_check() return Binding.objects.create(settlement_sn=settlement_sn, sku_code=sku_code, enable=True) 先判断这样的Binding是否存在，存在的话就直接抛异常，不存在的话再进行其他的校验，最后生成对应的Binding。一般情况下没问题，但是如果并发请求的sku_code和settlement_sn都相同，接到请求的几个worker同时从数据库查询发现目标binding不存在，做出可以创建的判断（因为下面存在一些耗时的校验让这种情况的概率变得很高），然后就创建了sku_code和settlement_sn都相同的记录。 因为是公司内部使用的财务规则系统，也就几个人在用，所以做的时候没怎么考虑并发问题。最后发现其实是前端没有做按钮的防重点，用户连续在按钮上点了两下，造成了这个问题。 我们用的是pg（等下会说为什么强调是pg），这里其实是发生了幻读。那改事务隔离级别可以解决吗，可重复读和串行化不是能解决幻读吗。。。。。肯定不行，一言不合就改数据库事务隔离级别肯定是不行的，而且改了也没法解决这种幻读问题(后来才知道其实串行化可以，但需要加上失败重试的逻辑)。那加锁吧！当时也没多想，迷迷糊糊的在判断上加个锁：
def create_binding(sku_code, settlement_sn)： if not Binding.objects.filter(sku_code=sku_code, settlement_sn=settlement_sn, enable=True).select_for_update).exist(): raise OperationError(&#39;binding_created&#39;) ..... 查询上加上select_for_update()，阻塞住并发的读，完美！发到测试环境，一看，并不行&hellip;还是会生成重，再回头看才明白这个锁有问题。首先，django的select_for_update加上exist()其实是不会生成&rsquo;select &hellip; for update&rsquo;语句的，然后就算生成了，但是因为没有这样的数据，所以没有row可以被锁，这个锁其实没有任何作用。
解决 那怎么解决呢，分布式锁肯定是可以的，给判断的代码块加上锁，这样创建binding的请求就变成串行的了，如果对并发没要求，比如我们这种场景为了防止重点，可以使用这种办法。代码块就变成这样了：
def create_binding(sku_code, settlement_sn)： # 获取分布式锁 get_lock() if not Binding.objects.filter(sku_code=sku_code, settlement_sn=settlement_sn, enable=True).exist(): raise OperationError(&#39;binding_created&#39;) # 一系列有些耗时的校验 do_some_check() result = Binding.objects.create(settlement_sn=settlement_sn, sku_code=sku_code, enable=True) # 释放分布式锁 release_lock() return result 除此之外有没有别的办法呢，其实我们就是想锁住一个“不存在”的一行，google了一下，搜到一篇文章：https://rosscoded.com/blog/2018/05/02/locking-phantom-postgresql/，这里面在pg的数据库级别给出了解决办法。首先可以使用ON CONFLICT语句，其次还可以使用advisory locks，劝告锁，这是pg独有的一种锁，思路挺有意思，不过这是库级别的锁，用多了也不好。但是这些都得在代码里面写sql，最后我们还是选择了基于redis的简单的分布式锁来解决。
回到之前说的，为啥强调是pg呢，因为后来试了一下，在mysql里面，其实是可以给不存在的数据加锁的，mysql里面这个叫gap lock，间隙锁，专门用来解决幻读问题。比如直接select * from binding where sku_code = &quot;123&quot; for update其实会同时加record Lock和gap lock，把已经存在的sku_code=123的行给锁住，同时还会锁住不存在的这些目标行，就是这时其他事务其实是没法写sku_code=123的数据的。mysql只有在可重复读以上的隔离级别才会自动加gap lock。"/>



<link rel="stylesheet" href="https://schecterdamien.github.io/fontawesome/css/all.min.css" />




<link
  crossorigin="anonymous"
  href="/css/styles.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>




<link
  id="dark-mode-theme"
  crossorigin="anonymous"
  href="/css/dark.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>


<script>
  var darkTheme = document.getElementById('dark-mode-theme')
  var storedTheme = localStorage.getItem('dark-mode-storage')

  if (storedTheme === 'dark') {
    darkTheme.disabled = false
  } else if (storedTheme === 'light') {
    darkTheme.disabled = true
  }
</script>


<script defer crossorigin="anonymous" src="/js/theme.js" integrity=""></script>


<script defer crossorigin="anonymous" src="/js/instantpage.min.js" integrity=""></script><meta name="generator" content="Hugo 0.101.0" />
  </head>
  <body>
    
  




  <header>
    <nav class="navbar">
  <div class="nav">
    
      <a href="https://schecterdamien.github.io/" class="nav-logo">
        <img
          src="https://schecterdamien.github.io/images/icon.png"
          width="50"
          height="50"
          alt="Logo"
        />
      </a>
    

    <ul class="nav-links">
      
        
          <li>
            <a href="/about/" id="About"
              ><em class="fas fa-user fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/tags" id="Tags"
              ><em class="fas fa-tag fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/search" id="Search"
              ><em class="fas fa-search fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/archives" id="Archives"
              ><em class="fas fa-archive fa-lg"></em
            ></a>
          </li>
          
      
    </ul>
  </div>
</nav>

    <div class="intro-header">
      <div class="container">
        <div class="posts-heading">
          
            <h1>
              记一次并发问题的排查
            </h1>
          
          
        </div>
      </div>
    </div>
  </header>
  

    
  <div class="container" role="main">
    <article class="article" class="blog-post">
      
  <h3 id="起源">起源</h3>
<p>     事情的起源是这样的，Binding是一张多对多的表，主要有sku_code，settlement_sn，enable这几个字段，但是逻辑上sku_code，settlemen_sn，enable=True的在表中应该是唯一的。因为enable=False可能有多条，所以不能在数据库上加联合唯一的索引，但是代码里面有判断。然后有一天测试发现出现两条记录的sku_code，settlemen_sn相同且enable都为True，然后看代码，创建Binding的代码大致是这样的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">create_binding</span>(sku_code, settlement_sn)<span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> Binding<span style="color:#f92672">.</span>objects<span style="color:#f92672">.</span>filter(sku_code<span style="color:#f92672">=</span>sku_code, settlement_sn<span style="color:#f92672">=</span>settlement_sn, enable<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)<span style="color:#f92672">.</span>exist():
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> OperationError(<span style="color:#e6db74">&#39;binding_created&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 一系列有些耗时的校验</span>
</span></span><span style="display:flex;"><span>    do_some_check()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Binding<span style="color:#f92672">.</span>objects<span style="color:#f92672">.</span>create(settlement_sn<span style="color:#f92672">=</span>settlement_sn, sku_code<span style="color:#f92672">=</span>sku_code, enable<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span></code></pre></div><p>     先判断这样的Binding是否存在，存在的话就直接抛异常，不存在的话再进行其他的校验，最后生成对应的Binding。一般情况下没问题，但是如果并发请求的sku_code和settlement_sn都相同，接到请求的几个worker同时从数据库查询发现目标binding不存在，做出可以创建的判断（因为下面存在一些耗时的校验让这种情况的概率变得很高），然后就创建了sku_code和settlement_sn都相同的记录。
     因为是公司内部使用的财务规则系统，也就几个人在用，所以做的时候没怎么考虑并发问题。最后发现其实是前端没有做按钮的防重点，用户连续在按钮上点了两下，造成了这个问题。
     我们用的是pg（等下会说为什么强调是pg），这里其实是发生了<code>幻读</code>。那改事务隔离级别可以解决吗，<code>可重复读</code>和<code>串行化</code>不是能解决<code>幻读</code>吗。。。。。肯定不行，一言不合就改数据库事务隔离级别肯定是不行的，而且改了也没法解决这种<code>幻读</code>问题(后来才知道其实<code>串行化</code>可以，但需要加上失败重试的逻辑)。那加锁吧！当时也没多想，迷迷糊糊的在判断上加个锁：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">create_binding</span>(sku_code, settlement_sn)<span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> Binding<span style="color:#f92672">.</span>objects<span style="color:#f92672">.</span>filter(sku_code<span style="color:#f92672">=</span>sku_code, settlement_sn<span style="color:#f92672">=</span>settlement_sn, enable<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)<span style="color:#f92672">.</span>select_for_update)<span style="color:#f92672">.</span>exist():
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> OperationError(<span style="color:#e6db74">&#39;binding_created&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.....</span>
</span></span></code></pre></div><p>     查询上加上select_for_update()，阻塞住并发的读，完美！发到测试环境，一看，并不行&hellip;还是会生成重，再回头看才明白这个锁有问题。首先，django的<code>select_for_update</code>加上exist()其实是不会生成&rsquo;select &hellip; for update&rsquo;语句的，然后就算生成了，但是因为没有这样的数据，所以没有row可以被锁，这个锁其实没有任何作用。</p>
<h3 id="解决">解决</h3>
<p>     那怎么解决呢，分布式锁肯定是可以的，给判断的代码块加上锁，这样创建binding的请求就变成串行的了，如果对并发没要求，比如我们这种场景为了防止重点，可以使用这种办法。代码块就变成这样了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">create_binding</span>(sku_code, settlement_sn)<span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 获取分布式锁</span>
</span></span><span style="display:flex;"><span>    get_lock()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> Binding<span style="color:#f92672">.</span>objects<span style="color:#f92672">.</span>filter(sku_code<span style="color:#f92672">=</span>sku_code, settlement_sn<span style="color:#f92672">=</span>settlement_sn, enable<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)<span style="color:#f92672">.</span>exist():
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> OperationError(<span style="color:#e6db74">&#39;binding_created&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 一系列有些耗时的校验</span>
</span></span><span style="display:flex;"><span>    do_some_check()
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> Binding<span style="color:#f92672">.</span>objects<span style="color:#f92672">.</span>create(settlement_sn<span style="color:#f92672">=</span>settlement_sn, sku_code<span style="color:#f92672">=</span>sku_code, enable<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 释放分布式锁</span>
</span></span><span style="display:flex;"><span>    release_lock()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span></code></pre></div><p>     除此之外有没有别的办法呢，其实我们就是想锁住一个“不存在”的一行，google了一下，搜到一篇文章：<a href="https://rosscoded.com/blog/2018/05/02/locking-phantom-postgresql/">https://rosscoded.com/blog/2018/05/02/locking-phantom-postgresql/</a>，这里面在pg的数据库级别给出了解决办法。首先可以使用<code>ON CONFLICT</code>语句，其次还可以使用<code>advisory locks</code>，劝告锁，这是pg独有的一种锁，思路挺有意思，不过这是库级别的锁，用多了也不好。但是这些都得在代码里面写sql，最后我们还是选择了基于redis的简单的分布式锁来解决。<br>
     回到之前说的，为啥强调是pg呢，因为后来试了一下，在mysql里面，其实是可以给不存在的数据加锁的，mysql里面这个叫<code>gap lock</code>，间隙锁，专门用来解决<code>幻读</code>问题。比如直接<code>select * from binding where sku_code = &quot;123&quot; for update</code>其实会同时加<code>record Lock</code>和<code>gap lock</code>，把已经存在的<code>sku_code=123</code>的行给锁住，同时还会锁住不存在的这些目标行，就是这时其他事务其实是没法写<code>sku_code=123</code>的数据的。mysql只有在<code>可重复读</code>以上的隔离级别才会自动加<code>gap lock</code>。<br>
     之后有空再详细写写上面的几种锁。</p>
<h3 id="参考链接">参考链接</h3>
<ul>
<li><a href="https://rosscoded.com/blog/2018/05/02/locking-phantom-postgresql/">https://rosscoded.com/blog/2018/05/02/locking-phantom-postgresql/</a></li>
<li><a href="https://ningyu1.github.io/site/post/50-mysql-gap-lock/">https://ningyu1.github.io/site/post/50-mysql-gap-lock/</a></li>
</ul>




      
        <div class="blog-tags">
          
            <a
              href="https://schecterdamien.github.io/tags/python/"
              >python</a
            >&nbsp;
          
        </div>
      

      
        <ul class="bottomnav"><li class="previous"><a href="/posts/2019/pg-mvcc/"
          ><span>&lt;&lt;&nbsp;</span>PostgreSQL的事务隔离和MVCC</a
        ></li><li class="next"><a href="/posts/2019/cuckoo-filter/"
          >Cuckoo Filter<span>&nbsp;>></span></a
        ></li></ul>

      
    </article>
    
    
      

    
  </div>

    <footer>
  

<div class="social-icons">
  
    
    
      
      <a href="link%20to%20social%20media" name="name of social media">
        <em class="A icon from https://fontawesome.com/"></em>
      </a>
    
  

  
</div>


  
  <div class="container">
    <p class="credits copyright">
      <a href="https://schecterdamien.github.io/about">wujinjing</a>
      &nbsp;&copy;
      2021
      
      &nbsp;&ndash;&nbsp;
      <em class="fas fa-moon" id="dark-mode-toggle"></em>
    </p>

    <p class="credits theme-by">
       <a href="https://gohugo.io">Hugo</a>&nbsp;
      
      <a href="https://github.com/matsuyoshi30/harbor">Harbor</a>
    </p>
  </div>
</footer>

  </body>
</html>
